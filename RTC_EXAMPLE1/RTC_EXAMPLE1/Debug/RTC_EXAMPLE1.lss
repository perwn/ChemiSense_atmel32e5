
RTC_EXAMPLE1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000530  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00802000  00000530  000005c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000e  00802006  00802006  000005ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005ca  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000110  00000000  00000000  000005fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001c89  00000000  00000000  0000070a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a00  00000000  00000000  00002393  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002268  00000000  00000000  00002d93  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000023c  00000000  00000000  00004ffc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0002771c  00000000  00000000  00005238  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000704  00000000  00000000  0002c954  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000f8  00000000  00000000  0002d058  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00009e18  00000000  00000000  0002d150  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	55 c0       	rjmp	.+170    	; 0xac <__ctors_end>
   2:	00 00       	nop
   4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
   6:	00 00       	nop
   8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
   a:	00 00       	nop
   c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
   e:	00 00       	nop
  10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
  12:	00 00       	nop
  14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
  16:	00 00       	nop
  18:	64 c0       	rjmp	.+200    	; 0xe2 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	56 c1       	rjmp	.+684    	; 0x2ca <__vector_7>
  1e:	00 00       	nop
  20:	6d c1       	rjmp	.+730    	; 0x2fc <__vector_8>
  22:	00 00       	nop
  24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
  26:	00 00       	nop
  28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
  2e:	00 00       	nop
  30:	58 c0       	rjmp	.+176    	; 0xe2 <__bad_interrupt>
  32:	00 00       	nop
  34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
  36:	00 00       	nop
  38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
  3e:	00 00       	nop
  40:	50 c0       	rjmp	.+160    	; 0xe2 <__bad_interrupt>
  42:	00 00       	nop
  44:	4e c0       	rjmp	.+156    	; 0xe2 <__bad_interrupt>
  46:	00 00       	nop
  48:	4c c0       	rjmp	.+152    	; 0xe2 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
  4e:	00 00       	nop
  50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
  52:	00 00       	nop
  54:	46 c0       	rjmp	.+140    	; 0xe2 <__bad_interrupt>
  56:	00 00       	nop
  58:	44 c0       	rjmp	.+136    	; 0xe2 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
  5e:	00 00       	nop
  60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
  62:	00 00       	nop
  64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
  66:	00 00       	nop
  68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
  6e:	00 00       	nop
  70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
  72:	00 00       	nop
  74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
  76:	00 00       	nop
  78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
  7e:	00 00       	nop
  80:	30 c0       	rjmp	.+96     	; 0xe2 <__bad_interrupt>
  82:	00 00       	nop
  84:	2e c0       	rjmp	.+92     	; 0xe2 <__bad_interrupt>
  86:	00 00       	nop
  88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	2a c0       	rjmp	.+84     	; 0xe2 <__bad_interrupt>
  8e:	00 00       	nop
  90:	28 c0       	rjmp	.+80     	; 0xe2 <__bad_interrupt>
  92:	00 00       	nop
  94:	26 c0       	rjmp	.+76     	; 0xe2 <__bad_interrupt>
  96:	00 00       	nop
  98:	24 c0       	rjmp	.+72     	; 0xe2 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	22 c0       	rjmp	.+68     	; 0xe2 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	20 c0       	rjmp	.+64     	; 0xe2 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	1e c0       	rjmp	.+60     	; 0xe2 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	1c c0       	rjmp	.+56     	; 0xe2 <__bad_interrupt>
	...

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	cd bf       	out	0x3d, r28	; 61
  b4:	df e2       	ldi	r29, 0x2F	; 47
  b6:	de bf       	out	0x3e, r29	; 62

000000b8 <__do_copy_data>:
  b8:	10 e2       	ldi	r17, 0x20	; 32
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b0 e2       	ldi	r27, 0x20	; 32
  be:	e0 e3       	ldi	r30, 0x30	; 48
  c0:	f5 e0       	ldi	r31, 0x05	; 5
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
  c4:	05 90       	lpm	r0, Z+
  c6:	0d 92       	st	X+, r0
  c8:	a6 30       	cpi	r26, 0x06	; 6
  ca:	b1 07       	cpc	r27, r17
  cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
  ce:	20 e2       	ldi	r18, 0x20	; 32
  d0:	a6 e0       	ldi	r26, 0x06	; 6
  d2:	b0 e2       	ldi	r27, 0x20	; 32
  d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
  d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
  d8:	a4 31       	cpi	r26, 0x14	; 20
  da:	b2 07       	cpc	r27, r18
  dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
  de:	c4 d1       	rcall	.+904    	; 0x468 <main>
  e0:	25 c2       	rjmp	.+1098   	; 0x52c <_exit>

000000e2 <__bad_interrupt>:
  e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
  e4:	8f ef       	ldi	r24, 0xFF	; 255
  e6:	80 93 70 00 	sts	0x0070, r24
  ea:	80 93 71 00 	sts	0x0071, r24
  ee:	80 93 72 00 	sts	0x0072, r24
  f2:	80 93 73 00 	sts	0x0073, r24
  f6:	80 93 74 00 	sts	0x0074, r24
  fa:	80 93 75 00 	sts	0x0075, r24
  fe:	80 93 76 00 	sts	0x0076, r24
		osc_enable(OSC_ID_XOSC);
		osc_wait_ready(OSC_ID_XOSC);
		break;
	}

	CLK.RTCCTRL = id | CLK_RTCEN_bm;
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	e0 e4       	ldi	r30, 0x40	; 64
 106:	f0 e0       	ldi	r31, 0x00	; 0
 108:	83 83       	std	Z+3, r24	; 0x03
 10a:	08 95       	ret

0000010c <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
 10c:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
 10e:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
 110:	e8 2f       	mov	r30, r24
 112:	f0 e0       	ldi	r31, 0x00	; 0
 114:	e0 59       	subi	r30, 0x90	; 144
 116:	ff 4f       	sbci	r31, 0xFF	; 255
 118:	60 95       	com	r22
 11a:	80 81       	ld	r24, Z
 11c:	68 23       	and	r22, r24
 11e:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 120:	9f bf       	out	0x3f, r25	; 63
 122:	08 95       	ret

00000124 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
 124:	cf 93       	push	r28
 126:	df 93       	push	r29
 128:	fc 01       	movw	r30, r24
 12a:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
 12c:	20 e0       	ldi	r18, 0x00	; 0
 12e:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
 130:	c6 2f       	mov	r28, r22
 132:	d0 e0       	ldi	r29, 0x00	; 0
 134:	de 01       	movw	r26, r28
 136:	02 2e       	mov	r0, r18
 138:	02 c0       	rjmp	.+4      	; 0x13e <ioport_configure_port_pin+0x1a>
 13a:	b5 95       	asr	r27
 13c:	a7 95       	ror	r26
 13e:	0a 94       	dec	r0
 140:	e2 f7       	brpl	.-8      	; 0x13a <ioport_configure_port_pin+0x16>
 142:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
 144:	50 83       	st	Z, r21
 146:	2f 5f       	subi	r18, 0xFF	; 255
 148:	3f 4f       	sbci	r19, 0xFF	; 255
 14a:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
 14c:	28 30       	cpi	r18, 0x08	; 8
 14e:	31 05       	cpc	r19, r1
 150:	89 f7       	brne	.-30     	; 0x134 <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
 152:	40 ff       	sbrs	r20, 0
 154:	0a c0       	rjmp	.+20     	; 0x16a <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
 156:	41 ff       	sbrs	r20, 1
 158:	03 c0       	rjmp	.+6      	; 0x160 <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
 15a:	fc 01       	movw	r30, r24
 15c:	65 83       	std	Z+5, r22	; 0x05
 15e:	02 c0       	rjmp	.+4      	; 0x164 <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
 160:	fc 01       	movw	r30, r24
 162:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
 164:	fc 01       	movw	r30, r24
 166:	61 83       	std	Z+1, r22	; 0x01
 168:	02 c0       	rjmp	.+4      	; 0x16e <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
 16a:	fc 01       	movw	r30, r24
 16c:	62 83       	std	Z+2, r22	; 0x02
	}
}
 16e:	df 91       	pop	r29
 170:	cf 91       	pop	r28
 172:	08 95       	ret

00000174 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
 174:	43 e0       	ldi	r20, 0x03	; 3
 176:	50 e0       	ldi	r21, 0x00	; 0
 178:	61 e0       	ldi	r22, 0x01	; 1
 17a:	80 e0       	ldi	r24, 0x00	; 0
 17c:	96 e0       	ldi	r25, 0x06	; 6
 17e:	d2 df       	rcall	.-92     	; 0x124 <ioport_configure_port_pin>
 180:	43 e0       	ldi	r20, 0x03	; 3
 182:	50 e0       	ldi	r21, 0x00	; 0
 184:	62 e0       	ldi	r22, 0x02	; 2
 186:	80 e0       	ldi	r24, 0x00	; 0
 188:	96 e0       	ldi	r25, 0x06	; 6
 18a:	cc df       	rcall	.-104    	; 0x124 <ioport_configure_port_pin>
 18c:	43 e0       	ldi	r20, 0x03	; 3
 18e:	50 e0       	ldi	r21, 0x00	; 0
 190:	64 e0       	ldi	r22, 0x04	; 4
 192:	80 e0       	ldi	r24, 0x00	; 0
 194:	96 e0       	ldi	r25, 0x06	; 6
 196:	c6 df       	rcall	.-116    	; 0x124 <ioport_configure_port_pin>
 198:	43 e0       	ldi	r20, 0x03	; 3
 19a:	50 e0       	ldi	r21, 0x00	; 0
 19c:	68 e0       	ldi	r22, 0x08	; 8
 19e:	80 e0       	ldi	r24, 0x00	; 0
 1a0:	96 e0       	ldi	r25, 0x06	; 6
 1a2:	c0 df       	rcall	.-128    	; 0x124 <ioport_configure_port_pin>
 1a4:	43 e0       	ldi	r20, 0x03	; 3
 1a6:	50 e0       	ldi	r21, 0x00	; 0
 1a8:	60 e1       	ldi	r22, 0x10	; 16
 1aa:	80 e0       	ldi	r24, 0x00	; 0
 1ac:	96 e0       	ldi	r25, 0x06	; 6
 1ae:	ba df       	rcall	.-140    	; 0x124 <ioport_configure_port_pin>
 1b0:	43 e0       	ldi	r20, 0x03	; 3
 1b2:	50 e0       	ldi	r21, 0x00	; 0
 1b4:	60 e2       	ldi	r22, 0x20	; 32
 1b6:	80 e0       	ldi	r24, 0x00	; 0
 1b8:	96 e0       	ldi	r25, 0x06	; 6
 1ba:	b4 df       	rcall	.-152    	; 0x124 <ioport_configure_port_pin>
 1bc:	43 e0       	ldi	r20, 0x03	; 3
 1be:	50 e0       	ldi	r21, 0x00	; 0
 1c0:	60 e4       	ldi	r22, 0x40	; 64
 1c2:	80 e0       	ldi	r24, 0x00	; 0
 1c4:	96 e0       	ldi	r25, 0x06	; 6
 1c6:	ae df       	rcall	.-164    	; 0x124 <ioport_configure_port_pin>
 1c8:	43 e0       	ldi	r20, 0x03	; 3
 1ca:	50 e0       	ldi	r21, 0x00	; 0
 1cc:	60 e8       	ldi	r22, 0x80	; 128
 1ce:	80 e0       	ldi	r24, 0x00	; 0
 1d0:	96 e0       	ldi	r25, 0x06	; 6
 1d2:	a8 df       	rcall	.-176    	; 0x124 <ioport_configure_port_pin>
 1d4:	40 e0       	ldi	r20, 0x00	; 0
 1d6:	5e e1       	ldi	r21, 0x1E	; 30
 1d8:	61 e0       	ldi	r22, 0x01	; 1
 1da:	80 e6       	ldi	r24, 0x60	; 96
 1dc:	96 e0       	ldi	r25, 0x06	; 6
 1de:	a2 df       	rcall	.-188    	; 0x124 <ioport_configure_port_pin>
 1e0:	40 e0       	ldi	r20, 0x00	; 0
 1e2:	5e e1       	ldi	r21, 0x1E	; 30
 1e4:	62 e0       	ldi	r22, 0x02	; 2
 1e6:	80 e6       	ldi	r24, 0x60	; 96
 1e8:	96 e0       	ldi	r25, 0x06	; 6
 1ea:	9c df       	rcall	.-200    	; 0x124 <ioport_configure_port_pin>
 1ec:	40 e0       	ldi	r20, 0x00	; 0
 1ee:	5e e1       	ldi	r21, 0x1E	; 30
 1f0:	64 e0       	ldi	r22, 0x04	; 4
 1f2:	80 e6       	ldi	r24, 0x60	; 96
 1f4:	96 e0       	ldi	r25, 0x06	; 6
 1f6:	96 df       	rcall	.-212    	; 0x124 <ioport_configure_port_pin>
 1f8:	40 e0       	ldi	r20, 0x00	; 0
 1fa:	5e e1       	ldi	r21, 0x1E	; 30
 1fc:	68 e0       	ldi	r22, 0x08	; 8
 1fe:	80 e6       	ldi	r24, 0x60	; 96
 200:	96 e0       	ldi	r25, 0x06	; 6
 202:	90 cf       	rjmp	.-224    	; 0x124 <ioport_configure_port_pin>
 204:	08 95       	ret

00000206 <rtc_get_time>:
 */
void rtc_load_calibration(uint8_t error_value, uint8_t sign)
{
	/* Error, if sign flag not either 0 or 1*/
	Assert( sign <= 0x01);
	RTC.CALIB = sign | error_value;
 206:	0f 93       	push	r16
 208:	1f 93       	push	r17
 20a:	e0 e0       	ldi	r30, 0x00	; 0
 20c:	f4 e0       	ldi	r31, 0x04	; 4
 20e:	81 81       	ldd	r24, Z+1	; 0x01
 210:	80 fd       	sbrc	r24, 0
 212:	fd cf       	rjmp	.-6      	; 0x20e <rtc_get_time+0x8>
 214:	2f b7       	in	r18, 0x3f	; 63
 216:	f8 94       	cli
 218:	40 91 0c 20 	lds	r20, 0x200C
 21c:	50 91 0d 20 	lds	r21, 0x200D
 220:	e0 e0       	ldi	r30, 0x00	; 0
 222:	f4 e0       	ldi	r31, 0x04	; 4
 224:	80 85       	ldd	r24, Z+8	; 0x08
 226:	91 85       	ldd	r25, Z+9	; 0x09
 228:	00 97       	sbiw	r24, 0x00	; 0
 22a:	29 f4       	brne	.+10     	; 0x236 <rtc_get_time+0x30>
 22c:	33 81       	ldd	r19, Z+3	; 0x03
 22e:	30 ff       	sbrs	r19, 0
 230:	02 c0       	rjmp	.+4      	; 0x236 <rtc_get_time+0x30>
 232:	4f 5f       	subi	r20, 0xFF	; 255
 234:	5f 4f       	sbci	r21, 0xFF	; 255
 236:	2f bf       	out	0x3f, r18	; 63
 238:	60 e0       	ldi	r22, 0x00	; 0
 23a:	70 e0       	ldi	r23, 0x00	; 0
 23c:	ba 01       	movw	r22, r20
 23e:	55 27       	eor	r21, r21
 240:	44 27       	eor	r20, r20
 242:	a0 e0       	ldi	r26, 0x00	; 0
 244:	b0 e0       	ldi	r27, 0x00	; 0
 246:	8a 01       	movw	r16, r20
 248:	9b 01       	movw	r18, r22
 24a:	08 2b       	or	r16, r24
 24c:	19 2b       	or	r17, r25
 24e:	2a 2b       	or	r18, r26
 250:	3b 2b       	or	r19, r27
 252:	c9 01       	movw	r24, r18
 254:	b8 01       	movw	r22, r16
 256:	1f 91       	pop	r17
 258:	0f 91       	pop	r16
 25a:	08 95       	ret

0000025c <rtc_set_alarm>:
 25c:	e0 e0       	ldi	r30, 0x00	; 0
 25e:	f4 e0       	ldi	r31, 0x04	; 4
 260:	21 e0       	ldi	r18, 0x01	; 1
 262:	22 83       	std	Z+2, r18	; 0x02
 264:	64 87       	std	Z+12, r22	; 0x0c
 266:	75 87       	std	Z+13, r23	; 0x0d
 268:	60 93 10 20 	sts	0x2010, r22
 26c:	70 93 11 20 	sts	0x2011, r23
 270:	80 93 0e 20 	sts	0x200E, r24
 274:	90 93 0f 20 	sts	0x200F, r25
 278:	81 81       	ldd	r24, Z+1	; 0x01
 27a:	80 fd       	sbrc	r24, 0
 27c:	fd cf       	rjmp	.-6      	; 0x278 <rtc_set_alarm+0x1c>
 27e:	e0 e0       	ldi	r30, 0x00	; 0
 280:	f4 e0       	ldi	r31, 0x04	; 4
 282:	82 e0       	ldi	r24, 0x02	; 2
 284:	83 83       	std	Z+3, r24	; 0x03
 286:	85 e0       	ldi	r24, 0x05	; 5
 288:	82 83       	std	Z+2, r24	; 0x02
 28a:	08 95       	ret

0000028c <rtc_set_callback>:
 28c:	80 93 12 20 	sts	0x2012, r24
 290:	90 93 13 20 	sts	0x2013, r25
 294:	08 95       	ret

00000296 <rtc_init>:
 * \note The RTC clock source used by the RTC module should be set up before
 *       calling this function. 
 */
void rtc_init(void)
{
	sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
 296:	64 e0       	ldi	r22, 0x04	; 4
 298:	80 e0       	ldi	r24, 0x00	; 0
 29a:	38 df       	rcall	.-400    	; 0x10c <sysclk_enable_module>
	RTC.PER = 0xffff;
 29c:	e0 e0       	ldi	r30, 0x00	; 0
 29e:	f4 e0       	ldi	r31, 0x04	; 4
 2a0:	8f ef       	ldi	r24, 0xFF	; 255
 2a2:	9f ef       	ldi	r25, 0xFF	; 255
 2a4:	82 87       	std	Z+10, r24	; 0x0a
 2a6:	93 87       	std	Z+11, r25	; 0x0b
	RTC.CNT = 0;
 2a8:	10 86       	std	Z+8, r1	; 0x08
 2aa:	11 86       	std	Z+9, r1	; 0x09

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
 2ac:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
 2ae:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
 2b0:	e9 e0       	ldi	r30, 0x09	; 9
 2b2:	f0 e2       	ldi	r31, 0x20	; 32
 2b4:	90 81       	ld	r25, Z
 2b6:	9f 5f       	subi	r25, 0xFF	; 255
 2b8:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 2ba:	8f bf       	out	0x3f, r24	; 63
	/* Since overflow interrupt is needed all the time we limit sleep to
	 * power-save.
	 */
	sleepmgr_lock_mode(SLEEPMGR_PSAVE);
	RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
 2bc:	e0 e0       	ldi	r30, 0x00	; 0
 2be:	f4 e0       	ldi	r31, 0x04	; 4
 2c0:	81 e0       	ldi	r24, 0x01	; 1
 2c2:	82 83       	std	Z+2, r24	; 0x02
	RTC.CTRL = CONFIG_RTC_PRESCALER;
 2c4:	87 e0       	ldi	r24, 0x07	; 7
 2c6:	80 83       	st	Z, r24
 2c8:	08 95       	ret

000002ca <__vector_7>:
/**
 * \internal
 * \brief Overflow interrupt handling high counter
 */
ISR(RTC_OVF_vect)
{
 2ca:	1f 92       	push	r1
 2cc:	0f 92       	push	r0
 2ce:	0f b6       	in	r0, 0x3f	; 63
 2d0:	0f 92       	push	r0
 2d2:	11 24       	eor	r1, r1
 2d4:	8f 93       	push	r24
 2d6:	9f 93       	push	r25
 2d8:	ef 93       	push	r30
 2da:	ff 93       	push	r31
	rtc_data.counter_high++;
 2dc:	ec e0       	ldi	r30, 0x0C	; 12
 2de:	f0 e2       	ldi	r31, 0x20	; 32
 2e0:	80 81       	ld	r24, Z
 2e2:	91 81       	ldd	r25, Z+1	; 0x01
 2e4:	01 96       	adiw	r24, 0x01	; 1
 2e6:	80 83       	st	Z, r24
 2e8:	91 83       	std	Z+1, r25	; 0x01
}
 2ea:	ff 91       	pop	r31
 2ec:	ef 91       	pop	r30
 2ee:	9f 91       	pop	r25
 2f0:	8f 91       	pop	r24
 2f2:	0f 90       	pop	r0
 2f4:	0f be       	out	0x3f, r0	; 63
 2f6:	0f 90       	pop	r0
 2f8:	1f 90       	pop	r1
 2fa:	18 95       	reti

000002fc <__vector_8>:
/**
 * \internal
 * \brief Compare interrupt used for alarm
 */
ISR(RTC_COMP_vect)
{
 2fc:	1f 92       	push	r1
 2fe:	0f 92       	push	r0
 300:	0f b6       	in	r0, 0x3f	; 63
 302:	0f 92       	push	r0
 304:	11 24       	eor	r1, r1
 306:	cf 92       	push	r12
 308:	df 92       	push	r13
 30a:	ef 92       	push	r14
 30c:	ff 92       	push	r15
 30e:	0f 93       	push	r16
 310:	1f 93       	push	r17
 312:	2f 93       	push	r18
 314:	3f 93       	push	r19
 316:	4f 93       	push	r20
 318:	5f 93       	push	r21
 31a:	6f 93       	push	r22
 31c:	7f 93       	push	r23
 31e:	8f 93       	push	r24
 320:	9f 93       	push	r25
 322:	af 93       	push	r26
 324:	bf 93       	push	r27
 326:	ef 93       	push	r30
 328:	ff 93       	push	r31
	if (rtc_data.counter_high >= rtc_data.alarm_high) {
 32a:	40 91 0c 20 	lds	r20, 0x200C
 32e:	50 91 0d 20 	lds	r21, 0x200D
 332:	80 91 0e 20 	lds	r24, 0x200E
 336:	90 91 0f 20 	lds	r25, 0x200F
 33a:	48 17       	cp	r20, r24
 33c:	59 07       	cpc	r21, r25
 33e:	f0 f1       	brcs	.+124    	; 0x3bc <__vector_8+0xc0>
		RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
 340:	81 e0       	ldi	r24, 0x01	; 1
 342:	e0 e0       	ldi	r30, 0x00	; 0
 344:	f4 e0       	ldi	r31, 0x04	; 4
 346:	82 83       	std	Z+2, r24	; 0x02
		if (rtc_data.callback) {
 348:	e0 91 12 20 	lds	r30, 0x2012
 34c:	f0 91 13 20 	lds	r31, 0x2013
 350:	30 97       	sbiw	r30, 0x00	; 0
 352:	a1 f1       	breq	.+104    	; 0x3bc <__vector_8+0xc0>
			uint32_t count = ((uint32_t)rtc_data.counter_high << 16)
					| RTC.CNT;
 354:	a0 e0       	ldi	r26, 0x00	; 0
 356:	b4 e0       	ldi	r27, 0x04	; 4
 358:	18 96       	adiw	r26, 0x08	; 8
 35a:	8d 91       	ld	r24, X+
 35c:	9c 91       	ld	r25, X
 35e:	19 97       	sbiw	r26, 0x09	; 9
ISR(RTC_COMP_vect)
{
	if (rtc_data.counter_high >= rtc_data.alarm_high) {
		RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
		if (rtc_data.callback) {
			uint32_t count = ((uint32_t)rtc_data.counter_high << 16)
 360:	60 e0       	ldi	r22, 0x00	; 0
 362:	70 e0       	ldi	r23, 0x00	; 0
 364:	ba 01       	movw	r22, r20
 366:	55 27       	eor	r21, r21
 368:	44 27       	eor	r20, r20
					| RTC.CNT;
 36a:	a0 e0       	ldi	r26, 0x00	; 0
 36c:	b0 e0       	ldi	r27, 0x00	; 0
ISR(RTC_COMP_vect)
{
	if (rtc_data.counter_high >= rtc_data.alarm_high) {
		RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
		if (rtc_data.callback) {
			uint32_t count = ((uint32_t)rtc_data.counter_high << 16)
 36e:	8a 01       	movw	r16, r20
 370:	9b 01       	movw	r18, r22
 372:	08 2b       	or	r16, r24
 374:	19 2b       	or	r17, r25
 376:	2a 2b       	or	r18, r26
 378:	3b 2b       	or	r19, r27
 37a:	c9 01       	movw	r24, r18
 37c:	b8 01       	movw	r22, r16
					| RTC.CNT;
			uint32_t alarm = ((uint32_t)rtc_data.alarm_high << 16)
 37e:	00 91 0e 20 	lds	r16, 0x200E
 382:	10 91 0f 20 	lds	r17, 0x200F
 386:	20 e0       	ldi	r18, 0x00	; 0
 388:	30 e0       	ldi	r19, 0x00	; 0
 38a:	98 01       	movw	r18, r16
 38c:	11 27       	eor	r17, r17
 38e:	00 27       	eor	r16, r16
					| rtc_data.alarm_low;
 390:	c0 90 10 20 	lds	r12, 0x2010
 394:	d0 90 11 20 	lds	r13, 0x2011
 398:	e1 2c       	mov	r14, r1
 39a:	f1 2c       	mov	r15, r1
	if (rtc_data.counter_high >= rtc_data.alarm_high) {
		RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
		if (rtc_data.callback) {
			uint32_t count = ((uint32_t)rtc_data.counter_high << 16)
					| RTC.CNT;
			uint32_t alarm = ((uint32_t)rtc_data.alarm_high << 16)
 39c:	0c 29       	or	r16, r12
 39e:	1d 29       	or	r17, r13
 3a0:	2e 29       	or	r18, r14
 3a2:	3f 29       	or	r19, r15
					| rtc_data.alarm_low;
			/* Workaround for errata. Count might not be updated
			 * when waking up from sleep, so in this case use alarm
			 * time plus one.
			 */
			if (alarm >= count)
 3a4:	06 17       	cp	r16, r22
 3a6:	17 07       	cpc	r17, r23
 3a8:	28 07       	cpc	r18, r24
 3aa:	39 07       	cpc	r19, r25
 3ac:	30 f0       	brcs	.+12     	; 0x3ba <__vector_8+0xbe>
				count = alarm + 1;
 3ae:	c9 01       	movw	r24, r18
 3b0:	b8 01       	movw	r22, r16
 3b2:	6f 5f       	subi	r22, 0xFF	; 255
 3b4:	7f 4f       	sbci	r23, 0xFF	; 255
 3b6:	8f 4f       	sbci	r24, 0xFF	; 255
 3b8:	9f 4f       	sbci	r25, 0xFF	; 255
			rtc_data.callback(count);
 3ba:	09 95       	icall
		}
	}
}
 3bc:	ff 91       	pop	r31
 3be:	ef 91       	pop	r30
 3c0:	bf 91       	pop	r27
 3c2:	af 91       	pop	r26
 3c4:	9f 91       	pop	r25
 3c6:	8f 91       	pop	r24
 3c8:	7f 91       	pop	r23
 3ca:	6f 91       	pop	r22
 3cc:	5f 91       	pop	r21
 3ce:	4f 91       	pop	r20
 3d0:	3f 91       	pop	r19
 3d2:	2f 91       	pop	r18
 3d4:	1f 91       	pop	r17
 3d6:	0f 91       	pop	r16
 3d8:	ff 90       	pop	r15
 3da:	ef 90       	pop	r14
 3dc:	df 90       	pop	r13
 3de:	cf 90       	pop	r12
 3e0:	0f 90       	pop	r0
 3e2:	0f be       	out	0x3f, r0	; 63
 3e4:	0f 90       	pop	r0
 3e6:	1f 90       	pop	r1
 3e8:	18 95       	reti

000003ea <alarm>:
 *
 * This outputs the last two digits of current time in BCD on the board LEDS,
 * and then reschedules the alarm in 1 second.
 */
static void alarm(uint32_t time)
{
 3ea:	4f 92       	push	r4
 3ec:	5f 92       	push	r5
 3ee:	6f 92       	push	r6
 3f0:	7f 92       	push	r7
 3f2:	8f 92       	push	r8
 3f4:	9f 92       	push	r9
 3f6:	af 92       	push	r10
 3f8:	bf 92       	push	r11
 3fa:	cf 92       	push	r12
 3fc:	df 92       	push	r13
 3fe:	ef 92       	push	r14
 400:	ff 92       	push	r15
 402:	6b 01       	movw	r12, r22
 404:	7c 01       	movw	r14, r24
	/* Since the current time will give alarm when rolling over to
	 * next time unit, we just call with that one.
	 * This is safe to here since it's called from a time unit roll
	 * over.
	 */
	rtc_set_alarm(time);
 406:	2a df       	rcall	.-428    	; 0x25c <rtc_set_alarm>

	// Extract last two digits from time, and put them in bcd
	bcd = time % 10;
 408:	0f 2e       	mov	r0, r31
 40a:	fa e0       	ldi	r31, 0x0A	; 10
 40c:	8f 2e       	mov	r8, r31
 40e:	91 2c       	mov	r9, r1
 410:	a1 2c       	mov	r10, r1
 412:	b1 2c       	mov	r11, r1
 414:	f0 2d       	mov	r31, r0
 416:	c7 01       	movw	r24, r14
 418:	b6 01       	movw	r22, r12
 41a:	a5 01       	movw	r20, r10
 41c:	94 01       	movw	r18, r8
 41e:	64 d0       	rcall	.+200    	; 0x4e8 <__udivmodsi4>
 420:	2b 01       	movw	r4, r22
 422:	3c 01       	movw	r6, r24
	time -= bcd;
 424:	c7 01       	movw	r24, r14
 426:	b6 01       	movw	r22, r12
 428:	64 19       	sub	r22, r4
 42a:	75 09       	sbc	r23, r5
 42c:	86 09       	sbc	r24, r6
 42e:	97 09       	sbc	r25, r7
	time /= 10;
 430:	a5 01       	movw	r20, r10
 432:	94 01       	movw	r18, r8
 434:	59 d0       	rcall	.+178    	; 0x4e8 <__udivmodsi4>
	bcd = bcd | ((time % 10) << 4);
 436:	ca 01       	movw	r24, r20
 438:	b9 01       	movw	r22, r18
 43a:	a5 01       	movw	r20, r10
 43c:	94 01       	movw	r18, r8
 43e:	54 d0       	rcall	.+168    	; 0x4e8 <__udivmodsi4>
 440:	62 95       	swap	r22
 442:	60 7f       	andi	r22, 0xF0	; 240
 444:	46 2a       	or	r4, r22

	// LEDS on xplain are active low, so invert the output
	bcd = ~bcd;
 446:	40 94       	com	r4

	LED_PORT.OUT = bcd;
 448:	e0 e0       	ldi	r30, 0x00	; 0
 44a:	f6 e0       	ldi	r31, 0x06	; 6
 44c:	44 82       	std	Z+4, r4	; 0x04
}
 44e:	ff 90       	pop	r15
 450:	ef 90       	pop	r14
 452:	df 90       	pop	r13
 454:	cf 90       	pop	r12
 456:	bf 90       	pop	r11
 458:	af 90       	pop	r10
 45a:	9f 90       	pop	r9
 45c:	8f 90       	pop	r8
 45e:	7f 90       	pop	r7
 460:	6f 90       	pop	r6
 462:	5f 90       	pop	r5
 464:	4f 90       	pop	r4
 466:	08 95       	ret

00000468 <main>:
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
 468:	87 e0       	ldi	r24, 0x07	; 7
 46a:	e0 ea       	ldi	r30, 0xA0	; 160
 46c:	f0 e0       	ldi	r31, 0x00	; 0
 46e:	82 83       	std	Z+2, r24	; 0x02

int main(void)
{
	pmic_init();
	board_init();
 470:	81 de       	rcall	.-766    	; 0x174 <board_init>
	sysclk_init();
 472:	38 de       	rcall	.-912    	; 0xe4 <sysclk_init>
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
		sleepmgr_locks[i] = 0;
 474:	10 92 06 20 	sts	0x2006, r1
 478:	10 92 07 20 	sts	0x2007, r1
 47c:	10 92 08 20 	sts	0x2008, r1
 480:	10 92 09 20 	sts	0x2009, r1
 484:	10 92 0a 20 	sts	0x200A, r1
	}
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
 488:	81 e0       	ldi	r24, 0x01	; 1
 48a:	80 93 0b 20 	sts	0x200B, r24
	sleepmgr_init();

	rtc_init();
 48e:	03 df       	rcall	.-506    	; 0x296 <rtc_init>
	rtc_set_callback(alarm);
 490:	85 ef       	ldi	r24, 0xF5	; 245
 492:	91 e0       	ldi	r25, 0x01	; 1
 494:	fb de       	rcall	.-522    	; 0x28c <rtc_set_callback>

	cpu_irq_enable();
 496:	78 94       	sei
 * \note Without this errata this function can block for up to 1 RTC clock
 *       source cycle after waking up from sleep.
 */
static inline void rtc_set_alarm_relative(uint32_t offset)
{
        rtc_set_alarm(rtc_get_time() + offset);
 498:	b6 de       	rcall	.-660    	; 0x206 <rtc_get_time>
 49a:	e0 de       	rcall	.-576    	; 0x25c <rtc_set_alarm>

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
 49c:	c6 e0       	ldi	r28, 0x06	; 6
 49e:	d0 e2       	ldi	r29, 0x20	; 32
 4a0:	87 e0       	ldi	r24, 0x07	; 7
 4a2:	90 e2       	ldi	r25, 0x20	; 32
 *
 * \param mode Sleep mode, from the device IO header file.
 */
static inline void sleep_set_mode(enum SLEEP_SMODE_enum mode)
{
	SLEEP.CTRL = mode | (SLEEP.CTRL & ~SLEEP_SMODE_gm);
 4a4:	a8 e4       	ldi	r26, 0x48	; 72
 4a6:	b0 e0       	ldi	r27, 0x00	; 0
static inline void sleepmgr_enter_sleep(void)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	enum sleepmgr_mode sleep_mode;

	cpu_irq_disable();
 4a8:	f8 94       	cli

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
 4aa:	28 81       	ld	r18, Y
 4ac:	21 11       	cpse	r18, r1
 4ae:	07 c0       	rjmp	.+14     	; 0x4be <main+0x56>
 4b0:	fc 01       	movw	r30, r24
		lock_ptr++;
		sleep_mode = (enum sleepmgr_mode)(sleep_mode + 1);
 4b2:	2f 5f       	subi	r18, 0xFF	; 255

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
 4b4:	31 91       	ld	r19, Z+
 4b6:	33 23       	and	r19, r19
 4b8:	e1 f3       	breq	.-8      	; 0x4b2 <main+0x4a>
	cpu_irq_disable();

	// Find the deepest allowable sleep mode
	sleep_mode = sleepmgr_get_sleep_mode();
	// Return right away if first mode (ACTIVE) is locked.
	if (sleep_mode==SLEEPMGR_ACTIVE) {
 4ba:	21 11       	cpse	r18, r1
 4bc:	02 c0       	rjmp	.+4      	; 0x4c2 <main+0x5a>
		cpu_irq_enable();
 4be:	78 94       	sei
 4c0:	f3 cf       	rjmp	.-26     	; 0x4a8 <main+0x40>
 4c2:	3c 91       	ld	r19, X

static inline void sleepmgr_sleep(const enum sleepmgr_mode sleep_mode)
{
	Assert(sleep_mode != SLEEPMGR_ACTIVE);
#ifdef CONFIG_SLEEPMGR_ENABLE
	sleep_set_mode(sleepmgr_configs[sleep_mode-1]);
 4c4:	e2 2f       	mov	r30, r18
 4c6:	f0 e0       	ldi	r31, 0x00	; 0
 4c8:	e1 50       	subi	r30, 0x01	; 1
 4ca:	f0 4e       	sbci	r31, 0xE0	; 224
 4cc:	23 2f       	mov	r18, r19
 4ce:	21 7f       	andi	r18, 0xF1	; 241
 4d0:	30 81       	ld	r19, Z
 4d2:	23 2b       	or	r18, r19
 4d4:	2c 93       	st	X, r18
	sleep_enable();
 4d6:	2c 91       	ld	r18, X
 4d8:	21 60       	ori	r18, 0x01	; 1
 4da:	2c 93       	st	X, r18

	cpu_irq_enable();
 4dc:	78 94       	sei
	sleep_enter();
 4de:	88 95       	sleep

	sleep_disable();
 4e0:	2c 91       	ld	r18, X
 4e2:	2e 7f       	andi	r18, 0xFE	; 254
 4e4:	2c 93       	st	X, r18
 4e6:	e0 cf       	rjmp	.-64     	; 0x4a8 <main+0x40>

000004e8 <__udivmodsi4>:
 4e8:	a1 e2       	ldi	r26, 0x21	; 33
 4ea:	1a 2e       	mov	r1, r26
 4ec:	aa 1b       	sub	r26, r26
 4ee:	bb 1b       	sub	r27, r27
 4f0:	fd 01       	movw	r30, r26
 4f2:	0d c0       	rjmp	.+26     	; 0x50e <__udivmodsi4_ep>

000004f4 <__udivmodsi4_loop>:
 4f4:	aa 1f       	adc	r26, r26
 4f6:	bb 1f       	adc	r27, r27
 4f8:	ee 1f       	adc	r30, r30
 4fa:	ff 1f       	adc	r31, r31
 4fc:	a2 17       	cp	r26, r18
 4fe:	b3 07       	cpc	r27, r19
 500:	e4 07       	cpc	r30, r20
 502:	f5 07       	cpc	r31, r21
 504:	20 f0       	brcs	.+8      	; 0x50e <__udivmodsi4_ep>
 506:	a2 1b       	sub	r26, r18
 508:	b3 0b       	sbc	r27, r19
 50a:	e4 0b       	sbc	r30, r20
 50c:	f5 0b       	sbc	r31, r21

0000050e <__udivmodsi4_ep>:
 50e:	66 1f       	adc	r22, r22
 510:	77 1f       	adc	r23, r23
 512:	88 1f       	adc	r24, r24
 514:	99 1f       	adc	r25, r25
 516:	1a 94       	dec	r1
 518:	69 f7       	brne	.-38     	; 0x4f4 <__udivmodsi4_loop>
 51a:	60 95       	com	r22
 51c:	70 95       	com	r23
 51e:	80 95       	com	r24
 520:	90 95       	com	r25
 522:	9b 01       	movw	r18, r22
 524:	ac 01       	movw	r20, r24
 526:	bd 01       	movw	r22, r26
 528:	cf 01       	movw	r24, r30
 52a:	08 95       	ret

0000052c <_exit>:
 52c:	f8 94       	cli

0000052e <__stop_program>:
 52e:	ff cf       	rjmp	.-2      	; 0x52e <__stop_program>
